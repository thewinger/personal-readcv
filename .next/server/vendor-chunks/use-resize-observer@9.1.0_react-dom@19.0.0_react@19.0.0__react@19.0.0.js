"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-resize-observer@9.1.0_react-dom@19.0.0_react@19.0.0__react@19.0.0";
exports.ids = ["vendor-chunks/use-resize-observer@9.1.0_react-dom@19.0.0_react@19.0.0__react@19.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/use-resize-observer@9.1.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/use-resize-observer/dist/bundle.esm.js":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/use-resize-observer@9.1.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/use-resize-observer/dist/bundle.esm.js ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useResizeObserver)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.0.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// This could've been more streamlined with internal state instead of abusing\n// refs to such extent, but then composing hooks and components could not opt out of unnecessary renders.\nfunction useResolvedElement(subscriber, refOrElement) {\n  var lastReportRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var refOrElementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  refOrElementRef.current = refOrElement;\n  var cbElementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null); // Calling re-evaluation after each render without using a dep array,\n  // as the ref object's current value could've changed since the last render.\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    evaluateSubscription();\n  });\n  var evaluateSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    var cbElement = cbElementRef.current;\n    var refOrElement = refOrElementRef.current; // Ugly ternary. But smaller than an if-else block.\n\n    var element = cbElement ? cbElement : refOrElement ? refOrElement instanceof Element ? refOrElement : refOrElement.current : null;\n\n    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.subscriber === subscriber) {\n      return;\n    }\n\n    if (lastReportRef.current && lastReportRef.current.cleanup) {\n      lastReportRef.current.cleanup();\n    }\n\n    lastReportRef.current = {\n      element: element,\n      subscriber: subscriber,\n      // Only calling the subscriber, if there's an actual element to report.\n      // Setting cleanup to undefined unless a subscriber returns one, as an existing cleanup function would've been just called.\n      cleanup: element ? subscriber(element) : undefined\n    };\n  }, [subscriber]); // making sure we call the cleanup function on unmount\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    return function () {\n      if (lastReportRef.current && lastReportRef.current.cleanup) {\n        lastReportRef.current.cleanup();\n        lastReportRef.current = null;\n      }\n    };\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (element) {\n    cbElementRef.current = element;\n    evaluateSubscription();\n  }, [evaluateSubscription]);\n}\n\n// We're only using the first element of the size sequences, until future versions of the spec solidify on how\n// exactly it'll be used for fragments in multi-column scenarios:\n// From the spec:\n// > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,\n// > which occur in multi-column scenarios. However the current definitions of content rect and border box do not\n// > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single\n// > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.\n// > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)\n//\n// Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,\n// regardless of the \"box\" option.\n// The spec states the following on this:\n// > This does not have any impact on which box dimensions are returned to the defined callback when the event\n// > is fired, it solely defines which box the author wishes to observe layout changes on.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// I'm not exactly clear on what this means, especially when you consider a later section stating the following:\n// > This section is non-normative. An author may desire to observe more than one CSS box.\n// > In this case, author will need to use multiple ResizeObservers.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.\n// For this reason I decided to only return the requested size,\n// even though it seems we have access to results for all box types.\n// This also means that we get to keep the current api, being able to return a simple { width, height } pair,\n// regardless of box option.\nfunction extractSize(entry, boxProp, sizeType) {\n  if (!entry[boxProp]) {\n    if (boxProp === \"contentBoxSize\") {\n      // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.\n      // See the 6th step in the description for the RO algorithm:\n      // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h\n      // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of \"content-box\".\n      // In real browser implementations of course these objects differ, but the width/height values should be equivalent.\n      return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\n    }\n\n    return undefined;\n  } // A couple bytes smaller than calling Array.isArray() and just as effective here.\n\n\n  return entry[boxProp][0] ? entry[boxProp][0][sizeType] : // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current\n  // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.\n  // @ts-ignore\n  entry[boxProp][sizeType];\n}\n\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver.\n  var onResize = opts.onResize;\n  var onResizeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n  onResizeRef.current = onResize;\n  var round = opts.round || Math.round; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    width: undefined,\n    height: undefined\n  }),\n      size = _useState[0],\n      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n\n  var didUnmount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    didUnmount.current = false;\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders.\n\n  var previous = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (element) {\n    // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.\n    // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.\n    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {\n      resizeObserverRef.current = {\n        box: opts.box,\n        round: round,\n        instance: new ResizeObserver(function (entries) {\n          var entry = entries[0];\n          var boxProp = opts.box === \"border-box\" ? \"borderBoxSize\" : opts.box === \"device-pixel-content-box\" ? \"devicePixelContentBoxSize\" : \"contentBoxSize\";\n          var reportedWidth = extractSize(entry, boxProp, \"inlineSize\");\n          var reportedHeight = extractSize(entry, boxProp, \"blockSize\");\n          var newWidth = reportedWidth ? round(reportedWidth) : undefined;\n          var newHeight = reportedHeight ? round(reportedHeight) : undefined;\n\n          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n            var newSize = {\n              width: newWidth,\n              height: newHeight\n            };\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n\n            if (onResizeRef.current) {\n              onResizeRef.current(newSize);\n            } else {\n              if (!didUnmount.current) {\n                setSize(newSize);\n              }\n            }\n          }\n        })\n      };\n    }\n\n    resizeObserverRef.current.instance.observe(element, {\n      box: opts.box\n    });\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.instance.unobserve(element);\n      }\n    };\n  }, [opts.box, round]), opts.ref);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size.width, size.height]);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdXNlLXJlc2l6ZS1vYnNlcnZlckA5LjEuMF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy91c2UtcmVzaXplLW9ic2VydmVyL2Rpc3QvYnVuZGxlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2Q0FBTTtBQUM1Qix3QkFBd0IsNkNBQU07QUFDOUI7QUFDQSxxQkFBcUIsNkNBQU0sUUFBUTtBQUNuQzs7QUFFQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0gsNkJBQTZCLGtEQUFXO0FBQ3hDO0FBQ0EsZ0RBQWdEOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpQkFBaUI7O0FBRXBCLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyxrREFBVztBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsZ0JBQWdCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUFNO0FBQzFCO0FBQ0Esd0NBQXdDOztBQUV4QywwQkFBMEIsNkNBQU07O0FBRWhDLGtCQUFrQiwrQ0FBUTtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOEJBQThCO0FBQzlCOzs7QUFHQSxtQkFBbUIsNkNBQU07QUFDekIsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxPQUFPOztBQUVWLGlCQUFpQiw2Q0FBTTtBQUN2QjtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047QUFDQTs7QUFFQSx1Q0FBdUMsa0RBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsOENBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFd0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy93aW4vRGV2ZWxvcGVyL3JlYWRjdi9ub2RlX21vZHVsZXMvLnBucG0vdXNlLXJlc2l6ZS1vYnNlcnZlckA5LjEuMF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy91c2UtcmVzaXplLW9ic2VydmVyL2Rpc3QvYnVuZGxlLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG4vLyBUaGlzIGNvdWxkJ3ZlIGJlZW4gbW9yZSBzdHJlYW1saW5lZCB3aXRoIGludGVybmFsIHN0YXRlIGluc3RlYWQgb2YgYWJ1c2luZ1xuLy8gcmVmcyB0byBzdWNoIGV4dGVudCwgYnV0IHRoZW4gY29tcG9zaW5nIGhvb2tzIGFuZCBjb21wb25lbnRzIGNvdWxkIG5vdCBvcHQgb3V0IG9mIHVubmVjZXNzYXJ5IHJlbmRlcnMuXG5mdW5jdGlvbiB1c2VSZXNvbHZlZEVsZW1lbnQoc3Vic2NyaWJlciwgcmVmT3JFbGVtZW50KSB7XG4gIHZhciBsYXN0UmVwb3J0UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgcmVmT3JFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpO1xuICByZWZPckVsZW1lbnRSZWYuY3VycmVudCA9IHJlZk9yRWxlbWVudDtcbiAgdmFyIGNiRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKTsgLy8gQ2FsbGluZyByZS1ldmFsdWF0aW9uIGFmdGVyIGVhY2ggcmVuZGVyIHdpdGhvdXQgdXNpbmcgYSBkZXAgYXJyYXksXG4gIC8vIGFzIHRoZSByZWYgb2JqZWN0J3MgY3VycmVudCB2YWx1ZSBjb3VsZCd2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHJlbmRlci5cblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGV2YWx1YXRlU3Vic2NyaXB0aW9uKCk7XG4gIH0pO1xuICB2YXIgZXZhbHVhdGVTdWJzY3JpcHRpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNiRWxlbWVudCA9IGNiRWxlbWVudFJlZi5jdXJyZW50O1xuICAgIHZhciByZWZPckVsZW1lbnQgPSByZWZPckVsZW1lbnRSZWYuY3VycmVudDsgLy8gVWdseSB0ZXJuYXJ5LiBCdXQgc21hbGxlciB0aGFuIGFuIGlmLWVsc2UgYmxvY2suXG5cbiAgICB2YXIgZWxlbWVudCA9IGNiRWxlbWVudCA/IGNiRWxlbWVudCA6IHJlZk9yRWxlbWVudCA/IHJlZk9yRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgPyByZWZPckVsZW1lbnQgOiByZWZPckVsZW1lbnQuY3VycmVudCA6IG51bGw7XG5cbiAgICBpZiAobGFzdFJlcG9ydFJlZi5jdXJyZW50ICYmIGxhc3RSZXBvcnRSZWYuY3VycmVudC5lbGVtZW50ID09PSBlbGVtZW50ICYmIGxhc3RSZXBvcnRSZWYuY3VycmVudC5zdWJzY3JpYmVyID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxhc3RSZXBvcnRSZWYuY3VycmVudCAmJiBsYXN0UmVwb3J0UmVmLmN1cnJlbnQuY2xlYW51cCkge1xuICAgICAgbGFzdFJlcG9ydFJlZi5jdXJyZW50LmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICBsYXN0UmVwb3J0UmVmLmN1cnJlbnQgPSB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgc3Vic2NyaWJlcjogc3Vic2NyaWJlcixcbiAgICAgIC8vIE9ubHkgY2FsbGluZyB0aGUgc3Vic2NyaWJlciwgaWYgdGhlcmUncyBhbiBhY3R1YWwgZWxlbWVudCB0byByZXBvcnQuXG4gICAgICAvLyBTZXR0aW5nIGNsZWFudXAgdG8gdW5kZWZpbmVkIHVubGVzcyBhIHN1YnNjcmliZXIgcmV0dXJucyBvbmUsIGFzIGFuIGV4aXN0aW5nIGNsZWFudXAgZnVuY3Rpb24gd291bGQndmUgYmVlbiBqdXN0IGNhbGxlZC5cbiAgICAgIGNsZWFudXA6IGVsZW1lbnQgPyBzdWJzY3JpYmVyKGVsZW1lbnQpIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSwgW3N1YnNjcmliZXJdKTsgLy8gbWFraW5nIHN1cmUgd2UgY2FsbCB0aGUgY2xlYW51cCBmdW5jdGlvbiBvbiB1bm1vdW50XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGxhc3RSZXBvcnRSZWYuY3VycmVudCAmJiBsYXN0UmVwb3J0UmVmLmN1cnJlbnQuY2xlYW51cCkge1xuICAgICAgICBsYXN0UmVwb3J0UmVmLmN1cnJlbnQuY2xlYW51cCgpO1xuICAgICAgICBsYXN0UmVwb3J0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgY2JFbGVtZW50UmVmLmN1cnJlbnQgPSBlbGVtZW50O1xuICAgIGV2YWx1YXRlU3Vic2NyaXB0aW9uKCk7XG4gIH0sIFtldmFsdWF0ZVN1YnNjcmlwdGlvbl0pO1xufVxuXG4vLyBXZSdyZSBvbmx5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBzaXplIHNlcXVlbmNlcywgdW50aWwgZnV0dXJlIHZlcnNpb25zIG9mIHRoZSBzcGVjIHNvbGlkaWZ5IG9uIGhvd1xuLy8gZXhhY3RseSBpdCdsbCBiZSB1c2VkIGZvciBmcmFnbWVudHMgaW4gbXVsdGktY29sdW1uIHNjZW5hcmlvczpcbi8vIEZyb20gdGhlIHNwZWM6XG4vLyA+IFRoZSBib3ggc2l6ZSBwcm9wZXJ0aWVzIGFyZSBleHBvc2VkIGFzIEZyb3plbkFycmF5IGluIG9yZGVyIHRvIHN1cHBvcnQgZWxlbWVudHMgdGhhdCBoYXZlIG11bHRpcGxlIGZyYWdtZW50cyxcbi8vID4gd2hpY2ggb2NjdXIgaW4gbXVsdGktY29sdW1uIHNjZW5hcmlvcy4gSG93ZXZlciB0aGUgY3VycmVudCBkZWZpbml0aW9ucyBvZiBjb250ZW50IHJlY3QgYW5kIGJvcmRlciBib3ggZG8gbm90XG4vLyA+IG1lbnRpb24gaG93IHRob3NlIGJveGVzIGFyZSBhZmZlY3RlZCBieSBtdWx0aS1jb2x1bW4gbGF5b3V0LiBJbiB0aGlzIHNwZWMsIHRoZXJlIHdpbGwgb25seSBiZSBhIHNpbmdsZVxuLy8gPiBSZXNpemVPYnNlcnZlclNpemUgcmV0dXJuZWQgaW4gdGhlIEZyb3plbkFycmF5LCB3aGljaCB3aWxsIGNvcnJlc3BvbmQgdG8gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGZpcnN0IGNvbHVtbi5cbi8vID4gQSBmdXR1cmUgdmVyc2lvbiBvZiB0aGlzIHNwZWMgd2lsbCBleHRlbmQgdGhlIHJldHVybmVkIEZyb3plbkFycmF5IHRvIGNvbnRhaW4gdGhlIHBlci1mcmFnbWVudCBzaXplIGluZm9ybWF0aW9uLlxuLy8gKGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9yZXNpemUtb2JzZXJ2ZXIvI3Jlc2l6ZS1vYnNlcnZlci1lbnRyeS1pbnRlcmZhY2UpXG4vL1xuLy8gQWxzbywgdGVzdGluZyB0aGVzZSBuZXcgYm94IG9wdGlvbnMgcmV2ZWFsZWQgdGhhdCBpbiBib3RoIENocm9tZSBhbmQgRkYgZXZlcnl0aGluZyBpcyByZXR1cm5lZCBpbiB0aGUgY2FsbGJhY2ssXG4vLyByZWdhcmRsZXNzIG9mIHRoZSBcImJveFwiIG9wdGlvbi5cbi8vIFRoZSBzcGVjIHN0YXRlcyB0aGUgZm9sbG93aW5nIG9uIHRoaXM6XG4vLyA+IFRoaXMgZG9lcyBub3QgaGF2ZSBhbnkgaW1wYWN0IG9uIHdoaWNoIGJveCBkaW1lbnNpb25zIGFyZSByZXR1cm5lZCB0byB0aGUgZGVmaW5lZCBjYWxsYmFjayB3aGVuIHRoZSBldmVudFxuLy8gPiBpcyBmaXJlZCwgaXQgc29sZWx5IGRlZmluZXMgd2hpY2ggYm94IHRoZSBhdXRob3Igd2lzaGVzIHRvIG9ic2VydmUgbGF5b3V0IGNoYW5nZXMgb24uXG4vLyAoaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3Jlc2l6ZS1vYnNlcnZlci8jcmVzaXplLW9ic2VydmVyLWludGVyZmFjZSlcbi8vIEknbSBub3QgZXhhY3RseSBjbGVhciBvbiB3aGF0IHRoaXMgbWVhbnMsIGVzcGVjaWFsbHkgd2hlbiB5b3UgY29uc2lkZXIgYSBsYXRlciBzZWN0aW9uIHN0YXRpbmcgdGhlIGZvbGxvd2luZzpcbi8vID4gVGhpcyBzZWN0aW9uIGlzIG5vbi1ub3JtYXRpdmUuIEFuIGF1dGhvciBtYXkgZGVzaXJlIHRvIG9ic2VydmUgbW9yZSB0aGFuIG9uZSBDU1MgYm94LlxuLy8gPiBJbiB0aGlzIGNhc2UsIGF1dGhvciB3aWxsIG5lZWQgdG8gdXNlIG11bHRpcGxlIFJlc2l6ZU9ic2VydmVycy5cbi8vIChodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvcmVzaXplLW9ic2VydmVyLyNyZXNpemUtb2JzZXJ2ZXItaW50ZXJmYWNlKVxuLy8gV2hpY2ggaXMgY2xlYXJseSBub3QgaG93IGN1cnJlbnQgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgYmVoYXZlLCBhbmQgc2VlbXMgdG8gY29udHJhZGljdCB0aGUgcHJldmlvdXMgcXVvdGUuXG4vLyBGb3IgdGhpcyByZWFzb24gSSBkZWNpZGVkIHRvIG9ubHkgcmV0dXJuIHRoZSByZXF1ZXN0ZWQgc2l6ZSxcbi8vIGV2ZW4gdGhvdWdoIGl0IHNlZW1zIHdlIGhhdmUgYWNjZXNzIHRvIHJlc3VsdHMgZm9yIGFsbCBib3ggdHlwZXMuXG4vLyBUaGlzIGFsc28gbWVhbnMgdGhhdCB3ZSBnZXQgdG8ga2VlcCB0aGUgY3VycmVudCBhcGksIGJlaW5nIGFibGUgdG8gcmV0dXJuIGEgc2ltcGxlIHsgd2lkdGgsIGhlaWdodCB9IHBhaXIsXG4vLyByZWdhcmRsZXNzIG9mIGJveCBvcHRpb24uXG5mdW5jdGlvbiBleHRyYWN0U2l6ZShlbnRyeSwgYm94UHJvcCwgc2l6ZVR5cGUpIHtcbiAgaWYgKCFlbnRyeVtib3hQcm9wXSkge1xuICAgIGlmIChib3hQcm9wID09PSBcImNvbnRlbnRCb3hTaXplXCIpIHtcbiAgICAgIC8vIFRoZSBkaW1lbnNpb25zIGluIGBjb250ZW50Qm94U2l6ZWAgYW5kIGBjb250ZW50UmVjdGAgYXJlIGVxdWl2YWxlbnQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjLlxuICAgICAgLy8gU2VlIHRoZSA2dGggc3RlcCBpbiB0aGUgZGVzY3JpcHRpb24gZm9yIHRoZSBSTyBhbGdvcml0aG06XG4gICAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvcmVzaXplLW9ic2VydmVyLyNjcmVhdGUtYW5kLXBvcHVsYXRlLXJlc2l6ZW9ic2VydmVyZW50cnktaFxuICAgICAgLy8gPiBTZXQgdGhpcy5jb250ZW50UmVjdCB0byBsb2dpY2FsIHRoaXMuY29udGVudEJveFNpemUgZ2l2ZW4gdGFyZ2V0IGFuZCBvYnNlcnZlZEJveCBvZiBcImNvbnRlbnQtYm94XCIuXG4gICAgICAvLyBJbiByZWFsIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIG9mIGNvdXJzZSB0aGVzZSBvYmplY3RzIGRpZmZlciwgYnV0IHRoZSB3aWR0aC9oZWlnaHQgdmFsdWVzIHNob3VsZCBiZSBlcXVpdmFsZW50LlxuICAgICAgcmV0dXJuIGVudHJ5LmNvbnRlbnRSZWN0W3NpemVUeXBlID09PSBcImlubGluZVNpemVcIiA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gLy8gQSBjb3VwbGUgYnl0ZXMgc21hbGxlciB0aGFuIGNhbGxpbmcgQXJyYXkuaXNBcnJheSgpIGFuZCBqdXN0IGFzIGVmZmVjdGl2ZSBoZXJlLlxuXG5cbiAgcmV0dXJuIGVudHJ5W2JveFByb3BdWzBdID8gZW50cnlbYm94UHJvcF1bMF1bc2l6ZVR5cGVdIDogLy8gVFMgY29tcGxhaW5zIGFib3V0IHRoaXMsIGJlY2F1c2UgdGhlIFJPIGVudHJ5IHR5cGUgZm9sbG93cyB0aGUgc3BlYyBhbmQgZG9lcyBub3QgcmVmbGVjdCBGaXJlZm94J3MgY3VycmVudFxuICAvLyBiZWhhdmlvdXIgb2YgcmV0dXJuaW5nIG9iamVjdHMgaW5zdGVhZCBvZiBhcnJheXMgZm9yIGBib3JkZXJCb3hTaXplYCBhbmQgYGNvbnRlbnRCb3hTaXplYC5cbiAgLy8gQHRzLWlnbm9yZVxuICBlbnRyeVtib3hQcm9wXVtzaXplVHlwZV07XG59XG5cbmZ1bmN0aW9uIHVzZVJlc2l6ZU9ic2VydmVyKG9wdHMpIHtcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIC8vIFNhdmluZyB0aGUgY2FsbGJhY2sgYXMgYSByZWYuIFdpdGggdGhpcywgSSBkb24ndCBuZWVkIHRvIHB1dCBvblJlc2l6ZSBpbiB0aGVcbiAgLy8gZWZmZWN0IGRlcCBhcnJheSwgYW5kIGp1c3QgcGFzc2luZyBpbiBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gd2l0aG91dCBtZW1vaXNpbmdcbiAgLy8gd2lsbCBub3QgcmVpbnN0YW50aWF0ZSB0aGUgaG9vaydzIFJlc2l6ZU9ic2VydmVyLlxuICB2YXIgb25SZXNpemUgPSBvcHRzLm9uUmVzaXplO1xuICB2YXIgb25SZXNpemVSZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgb25SZXNpemVSZWYuY3VycmVudCA9IG9uUmVzaXplO1xuICB2YXIgcm91bmQgPSBvcHRzLnJvdW5kIHx8IE1hdGgucm91bmQ7IC8vIFVzaW5nIGEgc2luZ2xlIGluc3RhbmNlIHRocm91Z2hvdXQgdGhlIGhvb2sncyBsaWZldGltZVxuXG4gIHZhciByZXNpemVPYnNlcnZlclJlZiA9IHVzZVJlZigpO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSh7XG4gICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICBoZWlnaHQ6IHVuZGVmaW5lZFxuICB9KSxcbiAgICAgIHNpemUgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRTaXplID0gX3VzZVN0YXRlWzFdOyAvLyBJbiBjZXJ0YWluIGVkZ2UgY2FzZXMgdGhlIFJPIG1pZ2h0IHdhbnQgdG8gcmVwb3J0IGEgc2l6ZSBjaGFuZ2UganVzdCBhZnRlclxuICAvLyB0aGUgY29tcG9uZW50IHVubW91bnRlZC5cblxuXG4gIHZhciBkaWRVbm1vdW50ID0gdXNlUmVmKGZhbHNlKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBkaWRVbm1vdW50LmN1cnJlbnQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZGlkVW5tb3VudC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbXSk7IC8vIFVzaW5nIGEgcmVmIHRvIHRyYWNrIHRoZSBwcmV2aW91cyB3aWR0aCAvIGhlaWdodCB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZW5kZXJzLlxuXG4gIHZhciBwcmV2aW91cyA9IHVzZVJlZih7XG4gICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICBoZWlnaHQ6IHVuZGVmaW5lZFxuICB9KTsgLy8gVGhpcyBibG9jayBpcyBraW5kYSBsaWtlIGEgdXNlRWZmZWN0LCBvbmx5IGl0J3MgY2FsbGVkIHdoZW5ldmVyIGEgbmV3XG4gIC8vIGVsZW1lbnQgY291bGQgYmUgcmVzb2x2ZWQgYmFzZWQgb24gdGhlIHJlZiBvcHRpb24uIEl0IGFsc28gaGFzIGEgY2xlYW51cFxuICAvLyBmdW5jdGlvbi5cblxuICB2YXIgcmVmQ2FsbGJhY2sgPSB1c2VSZXNvbHZlZEVsZW1lbnQodXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBXZSBvbmx5IHVzZSBhIHNpbmdsZSBSZXNpemUgT2JzZXJ2ZXIgaW5zdGFuY2UsIGFuZCB3ZSdyZSBpbnN0YW50aWF0aW5nIGl0IG9uIGRlbWFuZCwgb25seSBvbmNlIHRoZXJlJ3Mgc29tZXRoaW5nIHRvIG9ic2VydmUuXG4gICAgLy8gVGhpcyBpbnN0YW5jZSBpcyBhbHNvIHJlY3JlYXRlZCB3aGVuIHRoZSBgYm94YCBvcHRpb24gY2hhbmdlcywgc28gdGhhdCBhIG5ldyBvYnNlcnZhdGlvbiBpcyBmaXJlZCBpZiB0aGVyZSB3YXMgYSBwcmV2aW91c2x5IG9ic2VydmVkIGVsZW1lbnQgd2l0aCBhIGRpZmZlcmVudCBib3ggb3B0aW9uLlxuICAgIGlmICghcmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudCB8fCByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmJveCAhPT0gb3B0cy5ib3ggfHwgcmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudC5yb3VuZCAhPT0gcm91bmQpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIGJveDogb3B0cy5ib3gsXG4gICAgICAgIHJvdW5kOiByb3VuZCxcbiAgICAgICAgaW5zdGFuY2U6IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgICAgICAgdmFyIGJveFByb3AgPSBvcHRzLmJveCA9PT0gXCJib3JkZXItYm94XCIgPyBcImJvcmRlckJveFNpemVcIiA6IG9wdHMuYm94ID09PSBcImRldmljZS1waXhlbC1jb250ZW50LWJveFwiID8gXCJkZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplXCIgOiBcImNvbnRlbnRCb3hTaXplXCI7XG4gICAgICAgICAgdmFyIHJlcG9ydGVkV2lkdGggPSBleHRyYWN0U2l6ZShlbnRyeSwgYm94UHJvcCwgXCJpbmxpbmVTaXplXCIpO1xuICAgICAgICAgIHZhciByZXBvcnRlZEhlaWdodCA9IGV4dHJhY3RTaXplKGVudHJ5LCBib3hQcm9wLCBcImJsb2NrU2l6ZVwiKTtcbiAgICAgICAgICB2YXIgbmV3V2lkdGggPSByZXBvcnRlZFdpZHRoID8gcm91bmQocmVwb3J0ZWRXaWR0aCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgdmFyIG5ld0hlaWdodCA9IHJlcG9ydGVkSGVpZ2h0ID8gcm91bmQocmVwb3J0ZWRIZWlnaHQpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKHByZXZpb3VzLmN1cnJlbnQud2lkdGggIT09IG5ld1dpZHRoIHx8IHByZXZpb3VzLmN1cnJlbnQuaGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBuZXdTaXplID0ge1xuICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJldmlvdXMuY3VycmVudC53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICAgICAgcHJldmlvdXMuY3VycmVudC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChvblJlc2l6ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIG9uUmVzaXplUmVmLmN1cnJlbnQobmV3U2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWRpZFVubW91bnQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldFNpemUobmV3U2l6ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQuaW5zdGFuY2Uub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBib3g6IG9wdHMuYm94XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyZXNpemVPYnNlcnZlclJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQuaW5zdGFuY2UudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtvcHRzLmJveCwgcm91bmRdKSwgb3B0cy5yZWYpO1xuICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZjogcmVmQ2FsbGJhY2ssXG4gICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHRcbiAgICB9O1xuICB9LCBbcmVmQ2FsbGJhY2ssIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0XSk7XG59XG5cbmV4cG9ydCB7IHVzZVJlc2l6ZU9ic2VydmVyIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/use-resize-observer@9.1.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/use-resize-observer/dist/bundle.esm.js\n");

/***/ })

};
;